<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="theme-color" content="#000000" />
    <meta name="description" content="Store Inventory Management Frontend" />
    <title>Store - Inventory Management</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen',
          'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue',
          sans-serif;
        -webkit-font-smoothing: antialiased;
        -moz-osx-font-smoothing: grayscale;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        min-height: 100vh;
        padding: 2rem;
      }

      .container {
        max-width: 1200px;
        margin: 0 auto;
        background: rgba(255,255,255,0.1);
        border-radius: 12px;
        padding: 2rem;
        backdrop-filter: blur(10px);
      }

      .header {
        text-align: center;
        margin-bottom: 2rem;
      }

      .header h1 {
        font-size: 2.5rem;
        margin-bottom: 0.5rem;
      }

      .header p {
        font-size: 1.2rem;
        opacity: 0.9;
      }

      .status {
        background: rgba(255,255,255,0.2);
        border-radius: 8px;
        padding: 1.5rem;
        margin-bottom: 2rem;
      }

      .status h2 {
        margin-bottom: 1rem;
        color: #fff;
      }

      .status-item {
        display: flex;
        justify-content: space-between;
        margin-bottom: 0.5rem;
        padding: 0.5rem;
        background: rgba(255,255,255,0.1);
        border-radius: 4px;
      }

      .btn {
        background: #3498db;
        color: white;
        border: none;
        padding: 1rem 2rem;
        border-radius: 6px;
        cursor: pointer;
        font-size: 1rem;
        margin: 0.5rem;
        transition: all 0.2s;
      }

      .btn:hover {
        background: #2980b9;
        transform: translateY(-1px);
      }

      .products {
        background: rgba(255,255,255,0.2);
        border-radius: 8px;
        padding: 1.5rem;
        margin-top: 2rem;
      }

      .loading {
        text-align: center;
        padding: 2rem;
      }

      .spinner {
        border: 4px solid rgba(255,255,255,0.3);
        border-top: 4px solid #fff;
        border-radius: 50%;
        width: 40px;
        height: 40px;
        animation: spin 2s linear infinite;
        margin: 0 auto 1rem;
      }

      @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
      }

      .error {
        background: rgba(231, 76, 60, 0.2);
        border: 1px solid rgba(231, 76, 60, 0.5);
        border-radius: 6px;
        padding: 1rem;
        margin: 1rem 0;
      }

      .success {
        background: rgba(46, 204, 113, 0.2);
        border: 1px solid rgba(46, 204, 113, 0.5);
        border-radius: 6px;
        padding: 1rem;
        margin: 1rem 0;
      }

      .products-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 1rem;
        flex-wrap: wrap;
        gap: 1rem;
      }

      .last-update-info {
        display: flex;
        align-items: center;
        background: rgba(255,255,255,0.1);
        padding: 0.5rem 1rem;
        border-radius: 20px;
        font-size: 0.9rem;
        color: rgba(255,255,255,0.9);
      }

      #last-update-display {
        font-weight: 500;
      }

      /* Auto-refresh styles removed for cleaner interface */

      .pagination {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-top: 1.5rem;
        padding: 1rem;
        background: rgba(255,255,255,0.1);
        border-radius: 8px;
      }

      .pagination-btn {
        background: rgba(255,255,255,0.2);
        border: 1px solid rgba(255,255,255,0.3);
        color: white;
        padding: 0.5rem 1rem;
        border-radius: 6px;
        cursor: pointer;
        transition: all 0.2s;
        font-size: 0.9rem;
      }

      .pagination-btn:hover:not(:disabled) {
        background: rgba(255,255,255,0.3);
        transform: translateY(-1px);
      }

      .pagination-btn:disabled {
        opacity: 0.5;
        cursor: not-allowed;
        transform: none;
      }

      .pagination-info {
        text-align: center;
        display: flex;
        flex-direction: column;
        gap: 0.2rem;
      }

      .pagination-info span {
        font-size: 0.9rem;
      }

      #total-info {
        opacity: 0.8;
        font-size: 0.8rem;
      }

      .product-grid {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
        gap: 1rem;
        margin: 1rem 0;
      }

      .product-card {
        background: rgba(255,255,255,0.1);
        border-radius: 8px;
        padding: 1rem;
        border: 1px solid rgba(255,255,255,0.2);
        transition: all 0.3s;
      }

      .product-card:hover {
        background: rgba(255,255,255,0.15);
        transform: translateY(-2px);
        box-shadow: 0 4px 20px rgba(0,0,0,0.2);
      }

      .product-card h3 {
        margin-bottom: 0.5rem;
        color: #fff;
        font-size: 1.1rem;
      }

      .product-header {
        margin-bottom: 15px;
        border-bottom: 1px solid rgba(255,255,255,0.2);
        padding-bottom: 10px;
      }

      .product-header h3 {
        margin: 0 0 5px 0;
        color: #fff;
        font-size: 1.2em;
      }

      /* Product ID styles removed - no longer displayed */

      .product-card p {
        margin-bottom: 0.3rem;
        font-size: 0.9rem;
      }

      .product-card strong {
        color: #fff;
      }

      .loading-overlay {
        position: relative;
      }

      .loading-overlay::after {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0,0,0,0.3);
        border-radius: 8px;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .refreshing {
        opacity: 0.7;
        transition: opacity 0.3s;
      }

      /* Shopping Cart Styles */
      .cart-btn {
        background: #28a745 !important;
        position: relative;
      }

      .cart-sidebar {
        position: fixed;
        top: 0;
        right: -400px;
        width: 400px;
        height: 100vh;
        background: white;
        color: #000000;
        box-shadow: -2px 0 10px rgba(0,0,0,0.1);
        transition: right 0.3s ease;
        z-index: 1000;
        display: flex;
        flex-direction: column;
      }

      .cart-sidebar.open {
        right: 0;
      }

      .cart-header {
        padding: 20px;
        border-bottom: 1px solid #eee;
        display: flex;
        justify-content: space-between;
        align-items: center;
        background: #f8f9fa;
        color: #000000;
      }

      .close-cart {
        background: none;
        border: none;
        font-size: 20px;
        cursor: pointer;
        color: #666;
      }

      .cart-items {
        flex: 1;
        overflow-y: auto;
        padding: 20px;
        color: #000000;
      }

      .cart-item {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 15px 0;
        border-bottom: 1px solid #eee;
        color: #000000;
      }

      .cart-item-info {
        flex: 1;
      }

      .cart-item-name {
        font-weight: bold;
        margin-bottom: 5px;
        color: #000000;
      }

      .cart-item-price {
        color: #666;
        font-size: 0.9em;
      }

      .cart-item-controls {
        display: flex;
        align-items: center;
        gap: 10px;
      }

      .quantity-btn {
        background: #007bff;
        color: white;
        border: none;
        width: 30px;
        height: 30px;
        border-radius: 50%;
        cursor: pointer;
        font-size: 16px;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .quantity-btn:hover {
        background: #0056b3;
      }

      .quantity-display {
        min-width: 30px;
        text-align: center;
        font-weight: bold;
      }

      .remove-item {
        background: #dc3545;
        color: white;
        border: none;
        padding: 5px 10px;
        border-radius: 4px;
        cursor: pointer;
        font-size: 12px;
      }

      .cart-footer {
        padding: 20px;
        border-top: 1px solid #eee;
        background: #f8f9fa;
        color: #000000;
      }

      .cart-total {
        margin-bottom: 15px;
        font-size: 18px;
        text-align: center;
        color: #000000;
      }

      .purchase-btn {
        background: #28a745 !important;
        width: 100%;
        margin-bottom: 10px;
      }

      .purchase-btn:disabled {
        background: #6c757d !important;
        cursor: not-allowed;
      }

      .clear-cart-btn {
        background: #dc3545 !important;
        width: 100%;
      }

      /* Modal Styles */
      .modal {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0,0,0,0.5);
        z-index: 2000;
        justify-content: center;
        align-items: center;
      }

      .modal.show {
        display: flex;
      }

      .modal-content {
        background: white;
        color: #000000;
        border-radius: 8px;
        width: 90%;
        max-width: 600px;
        max-height: 80vh;
        overflow-y: auto;
        box-shadow: 0 4px 20px rgba(0,0,0,0.3);
      }

      .modal-header {
        padding: 20px;
        border-bottom: 1px solid #eee;
        display: flex;
        justify-content: space-between;
        align-items: center;
        background: #f8f9fa;
        border-radius: 8px 8px 0 0;
        color: #000000;
      }

      .close-modal {
        background: none;
        border: none;
        font-size: 20px;
        cursor: pointer;
        color: #666;
      }

      .modal-body {
        padding: 20px;
        color: #000000;
      }

      .purchase-item {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 10px 0;
        border-bottom: 1px solid #eee;
      }

      .purchase-item-info {
        flex: 1;
      }

      .purchase-item-name {
        font-weight: bold;
        margin-bottom: 5px;
      }

      .purchase-item-details {
        color: #666;
        font-size: 0.9em;
      }

      .purchase-item-total {
        font-weight: bold;
        color: #28a745;
      }

      .purchase-total {
        margin-top: 20px;
        padding-top: 20px;
        border-top: 2px solid #eee;
        text-align: center;
        font-size: 20px;
        color: #28a745;
      }

      .modal-footer {
        padding: 20px;
        border-top: 1px solid #eee;
        display: flex;
        gap: 10px;
        justify-content: flex-end;
        background: #f8f9fa;
        border-radius: 0 0 8px 8px;
      }

      .cancel-btn {
        background: #6c757d !important;
      }

      .confirm-btn {
        background: #28a745 !important;
      }

      /* Loading Overlay */
      .loading-overlay {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0,0,0,0.7);
        z-index: 3000;
        justify-content: center;
        align-items: center;
      }

      .loading-overlay.show {
        display: flex;
      }

      .loading-spinner {
        background: white;
        padding: 40px;
        border-radius: 8px;
        text-align: center;
        box-shadow: 0 4px 20px rgba(0,0,0,0.3);
      }

      .loading-spinner .spinner {
        width: 40px;
        height: 40px;
        margin: 0 auto 20px;
      }

      /* Product Card Add to Cart Button */
      .add-to-cart-btn {
        background: #28a745 !important;
        margin-top: 10px;
        width: 100%;
      }

      .add-to-cart-btn:hover {
        background: #218838 !important;
      }

      .empty-cart {
        text-align: center;
        color: #666;
        padding: 40px 20px;
      }

      .empty-cart p {
        color: #666;
      }

      .empty-cart-icon {
        font-size: 48px;
        margin-bottom: 10px;
        color: #666;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <div class="header">
        <h1 id="store-title">🏪 Store Inventory</h1>
        <p>Frontend Application - Testing Mode</p>
      </div>

      <div class="status">
        <h2>📊 System Status</h2>
        <div class="status-item">
          <span>Frontend Status:</span>
          <span id="frontend-status">✅ Running</span>
        </div>
        <div class="status-item">
          <span id="store-api-label">Store API:</span>
          <span id="api-status">🔄 Checking...</span>
        </div>
        <div class="status-item">
          <span>Last Update:</span>
          <span id="last-update">-</span>
        </div>
        <div class="status-item">
          <span>Auto-Refresh:</span>
          <span id="auto-refresh-status">🔄 Active (5s)</span>
        </div>
      </div>

      <div style="text-align: center;">
        <button class="btn" onclick="testAPI()" id="test-api-btn">🔄 Test Store API</button>
        <button class="btn" onclick="loadProducts(false)">📦 Refresh Products</button>
        <button class="btn" onclick="toggleAutoRefresh()" id="auto-refresh-toggle">⏸️ Pause Auto-Refresh</button>
        <button class="btn" onclick="testHealth()">❤️ Health Check</button>
        <button class="btn" onclick="currentPage=1; loadProducts(false)">🏠 Reset to Page 1</button>
        <button class="btn cart-btn" onclick="toggleCart()">🛒 Cart (<span id="cart-count">0</span>)</button>
      </div>

      <div class="products">
        <div class="products-header">
          <h2>📦 Products</h2>
          <div class="last-update-info">
            <span id="last-update-display">Last Update: Loading...</span>
          </div>
        </div>

        <div id="products-content">
          <div class="loading">
            <div class="spinner"></div>
            <p>Loading products...</p>
          </div>
        </div>

        <div id="pagination-controls" class="pagination" style="display: none;">
          <button id="prev-btn" class="btn pagination-btn" onclick="previousPage()">← Previous</button>
          <div class="pagination-info">
            <span id="page-info">Page 1 of 1</span>
            <span id="total-info">(0 products total)</span>
          </div>
          <button id="next-btn" class="btn pagination-btn" onclick="nextPage()">Next →</button>
        </div>
      </div>
    </div>

    <!-- Shopping Cart Sidebar -->
    <div id="cart-sidebar" class="cart-sidebar">
      <div class="cart-header">
        <h3>🛒 Shopping Cart</h3>
        <button class="close-cart" onclick="toggleCart()">✕</button>
      </div>
      <div id="cart-items" class="cart-items">
        <!-- Cart items will be inserted here -->
      </div>
      <div class="cart-footer">
        <div class="cart-total">
          <strong>Total: $<span id="cart-total">0.00</span></strong>
        </div>
        <button class="btn purchase-btn" onclick="showPurchaseModal()" id="purchase-btn" disabled>
          💳 Purchase
        </button>
        <button class="btn clear-cart-btn" onclick="clearCart()">
          🗑️ Clear Cart
        </button>
      </div>
    </div>

    <!-- Purchase Modal -->
    <div id="purchase-modal" class="modal">
      <div class="modal-content">
        <div class="modal-header">
          <h3>💳 Purchase Summary</h3>
          <button class="close-modal" onclick="closePurchaseModal()">✕</button>
        </div>
        <div class="modal-body">
          <div id="purchase-summary">
            <!-- Purchase summary will be inserted here -->
          </div>
          <div class="purchase-total">
            <strong>Total Amount: $<span id="purchase-total">0.00</span></strong>
          </div>
        </div>
        <div class="modal-footer">
          <button class="btn cancel-btn" onclick="closePurchaseModal()">❌ Cancel</button>
          <button class="btn confirm-btn" onclick="confirmPurchase()" id="confirm-purchase-btn">
            ✅ Confirm Purchase
          </button>
        </div>
      </div>
    </div>

    <!-- Loading Overlay -->
    <div id="loading-overlay" class="loading-overlay">
      <div class="loading-spinner">
        <div class="spinner"></div>
        <p id="loading-message">Processing purchase...</p>
      </div>
    </div>

    <script>
      // Environment variables (injected at build time)
      const STORE_NAME = 'Store S1';
      const STORE_ID = 'store-s1';
      const API_KEY = 'demo';

      // Global state
      let currentPage = 1;
      let totalProducts = 0;
      let productsPerPage = 5;
      let allProducts = [];
      let lastRefreshTime = null;

      // Auto-refresh state
      let autoRefreshInterval = null;
      let autoRefreshEnabled = true;
      const AUTO_REFRESH_INTERVAL_MS = 5000; // 5 seconds

      // Shopping cart state
      let cart = [];
      let isCartOpen = false;
      let isLoading = false;

      // Shopping Cart Functions

      function addToCart(productId, productName, price, available, version) {
        console.log('🛒 addToCart called with:', { productId, productName, price, available, version });

        // Validate input parameters
        if (!productId || !productName) {
          console.error('❌ Invalid product data:', { productId, productName, price, available, version });
          showMessage(`Invalid product data`, 'error');
          return;
        }

        // Validate that price is a valid number
        if (typeof price !== 'number' || isNaN(price) || price <= 0) {
          console.error('❌ Invalid price for product:', productName, price);
          showMessage(`Invalid price for ${productName}`, 'error');
          return;
        }

        // Validate available quantity
        if (typeof available !== 'number' || isNaN(available) || available < 0) {
          console.error('❌ Invalid available quantity for product:', productName, available);
          showMessage(`Invalid stock data for ${productName}`, 'error');
          return;
        }

        // Ensure version is a valid number (default to 1 if not provided)
        const validVersion = (typeof version === 'number' && !isNaN(version)) ? version : 1;

        console.log('✅ Validated data, adding to cart:', { productId, productName, price, available, version: validVersion });

        // Check if product is already in cart
        const existingItem = cart.find(item => item.productId === productId);

        if (existingItem) {
          // Check if we can add more
          if (existingItem.quantity < available) {
            existingItem.quantity += 1;
            showMessage(`Added another ${productName} to cart`, 'success');
          } else {
            showMessage(`Cannot add more ${productName} - insufficient stock`, 'error');
            return;
          }
        } else {
          // Add new item to cart
          cart.push({
            productId,
            productName,
            price,
            quantity: 1,
            available,
            version: validVersion
          });
          showMessage(`${productName} added to cart`, 'success');
        }

        updateCartDisplay();
      }

      function removeFromCart(productId) {
        const index = cart.findIndex(item => item.productId === productId);
        if (index !== -1) {
          const item = cart[index];
          cart.splice(index, 1);
          showMessage(`${item.productName} removed from cart`, 'info');
          updateCartDisplay();
        }
      }

      function updateQuantity(productId, change) {
        const item = cart.find(item => item.productId === productId);
        if (!item) return;

        const newQuantity = item.quantity + change;

        if (newQuantity <= 0) {
          removeFromCart(productId);
          return;
        }

        if (newQuantity > item.available) {
          showMessage(`Cannot add more ${item.productName} - insufficient stock`, 'error');
          return;
        }

        item.quantity = newQuantity;
        updateCartDisplay();
      }

      function clearCart() {
        if (cart.length === 0) return;

        if (confirm('Are you sure you want to clear the cart?')) {
          cart = [];
          updateCartDisplay();
          showMessage('Cart cleared', 'info');
        }
      }

      function updateCartDisplay() {
        const cartCount = document.getElementById('cart-count');
        const cartItems = document.getElementById('cart-items');
        const cartTotal = document.getElementById('cart-total');
        const purchaseBtn = document.getElementById('purchase-btn');

        // Update cart count
        const totalItems = cart.reduce((sum, item) => sum + item.quantity, 0);
        cartCount.textContent = totalItems;

        // Update cart items
        if (cart.length === 0) {
          cartItems.innerHTML = `
            <div class="empty-cart">
              <div class="empty-cart-icon">🛒</div>
              <p>Your cart is empty</p>
              <p>Add some products to get started!</p>
            </div>
          `;
          cartTotal.textContent = '0.00';
          purchaseBtn.disabled = true;
        } else {
          let html = '';
          let total = 0;

          cart.forEach(item => {
            const itemTotal = item.price * item.quantity;
            total += itemTotal;

            html += `
              <div class="cart-item">
                <div class="cart-item-info">
                  <div class="cart-item-name">${item.productName}</div>
                  <div class="cart-item-price">$${item.price.toFixed(2)} each</div>
                </div>
                <div class="cart-item-controls">
                  <button class="quantity-btn" onclick="updateQuantity('${item.productId}', -1)">-</button>
                  <span class="quantity-display">${item.quantity}</span>
                  <button class="quantity-btn" onclick="updateQuantity('${item.productId}', 1)">+</button>
                  <button class="remove-item" onclick="removeFromCart('${item.productId}')">Remove</button>
                </div>
              </div>
            `;
          });

          cartItems.innerHTML = html;
          cartTotal.textContent = total.toFixed(2);
          purchaseBtn.disabled = false;
        }
      }

      function toggleCart() {
        const cartSidebar = document.getElementById('cart-sidebar');
        isCartOpen = !isCartOpen;

        if (isCartOpen) {
          cartSidebar.classList.add('open');
        } else {
          cartSidebar.classList.remove('open');
        }
      }

      // Purchase Functions
      function showPurchaseModal() {
        if (cart.length === 0) return;

        const modal = document.getElementById('purchase-modal');
        const summary = document.getElementById('purchase-summary');
        const total = document.getElementById('purchase-total');

        let html = '';
        let totalAmount = 0;

        cart.forEach(item => {
          const itemTotal = item.price * item.quantity;
          totalAmount += itemTotal;

          html += `
            <div class="purchase-item">
              <div class="purchase-item-info">
                <div class="purchase-item-name">${item.productName}</div>
                <div class="purchase-item-details">
                  Quantity: ${item.quantity} × $${item.price.toFixed(2)} = $${itemTotal.toFixed(2)}
                </div>
              </div>
              <div class="purchase-item-total">$${itemTotal.toFixed(2)}</div>
            </div>
          `;
        });

        summary.innerHTML = html;
        total.textContent = totalAmount.toFixed(2);
        modal.classList.add('show');
      }

      function closePurchaseModal() {
        const modal = document.getElementById('purchase-modal');
        modal.classList.remove('show');
      }

      function generateUUID() {
        return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
          const r = Math.random() * 16 | 0;
          const v = c == 'x' ? r : (r & 0x3 | 0x8);
          return v.toString(16);
        });
      }

      function showLoadingOverlay(message = 'Processing purchase...') {
        const overlay = document.getElementById('loading-overlay');
        const messageEl = document.getElementById('loading-message');
        messageEl.textContent = message;
        overlay.classList.add('show');
      }

      function hideLoadingOverlay() {
        const overlay = document.getElementById('loading-overlay');
        overlay.classList.remove('show');
      }

      async function confirmPurchase() {
        if (cart.length === 0) return;

        console.log(`🛒 Starting purchase process for ${cart.length} items`);

        // Pause auto-refresh during purchase to avoid conflicts
        const wasAutoRefreshEnabled = autoRefreshEnabled;
        if (autoRefreshEnabled) {
          console.log('⏸️ Temporarily pausing auto-refresh during purchase');
          stopAutoRefresh();
        }

        showLoadingOverlay('Initializing purchase...');
        closePurchaseModal();

        const purchaseResults = [];
        let successCount = 0;
        let failureCount = 0;
        const failureDetails = [];

        try {
          // Process each item in the cart sequentially to avoid overwhelming the API
          for (let i = 0; i < cart.length; i++) {
            const item = cart[i];
            console.log(`🔄 Processing item ${i + 1}/${cart.length}: ${item.productName}`);
            showLoadingOverlay(`Processing ${item.productName} (${i + 1}/${cart.length})...`);

            const result = await processPurchaseItem(item);
            purchaseResults.push(result);

            if (result.success) {
              successCount++;
              console.log(`✅ Successfully purchased ${item.productName} after ${result.totalAttempts} attempts`);
            } else {
              failureCount++;
              failureDetails.push({
                productName: item.productName,
                error: result.error,
                message: result.message,
                attempts: result.totalAttempts
              });
              console.error(`❌ Failed to purchase ${item.productName} after ${result.totalAttempts} attempts:`, result.error);
            }

            // Small delay between items to prevent API overload
            if (i < cart.length - 1) {
              await new Promise(resolve => setTimeout(resolve, 200));
            }
          }

          // Show results with detailed feedback
          hideLoadingOverlay();

          if (failureCount === 0) {
            const totalAttempts = purchaseResults.reduce((sum, r) => sum + r.totalAttempts, 0);
            showMessage(`🎉 Purchase successful! ${successCount} items purchased (${totalAttempts} total API calls).`, 'success');
            cart = []; // Clear cart on successful purchase
            updateCartDisplay();
            toggleCart(); // Close cart

            // Refresh products to show updated inventory
            setTimeout(() => loadProducts(true), 1000);
          } else if (successCount === 0) {
            // All items failed - provide detailed error information
            const errorSummary = generateErrorSummary(failureDetails);
            showMessage(`❌ Purchase failed for all items. ${errorSummary}`, 'error');
            console.error('All purchase attempts failed:', failureDetails);
          } else {
            // Partial success - provide detailed feedback
            const errorSummary = generateErrorSummary(failureDetails);
            showMessage(`⚠️ Partial success: ${successCount} items purchased, ${failureCount} failed. ${errorSummary}`, 'warning');

            // Remove successful items from cart
            cart = cart.filter(cartItem => {
              const result = purchaseResults.find(r => r.productId === cartItem.productId);
              return !result || !result.success;
            });
            updateCartDisplay();

            // Refresh products to show updated inventory
            setTimeout(() => loadProducts(true), 1000);
          }

          // Log detailed results for debugging
          console.log('📊 Purchase Results Summary:', {
            total: cart.length,
            successful: successCount,
            failed: failureCount,
            results: purchaseResults
          });

        } catch (error) {
          hideLoadingOverlay();
          console.error('❌ Unexpected error during purchase process:', error);
          showMessage('❌ Purchase failed due to unexpected system error. Please try again.', 'error');
        } finally {
          // Resume auto-refresh after purchase process completes
          if (wasAutoRefreshEnabled) {
            console.log('▶️ Resuming auto-refresh after purchase');
            autoRefreshEnabled = true;
            setTimeout(() => {
              startAutoRefresh();
            }, 2000); // Wait 2 seconds before resuming to allow for any final updates
          }
        }
      }

      // Generate user-friendly error summary
      function generateErrorSummary(failureDetails) {
        if (failureDetails.length === 0) return '';

        const errorCounts = {};
        failureDetails.forEach(failure => {
          const errorType = failure.error;
          errorCounts[errorType] = (errorCounts[errorType] || 0) + 1;
        });

        const errorMessages = [];
        if (errorCounts.insufficient_inventory) {
          errorMessages.push(`${errorCounts.insufficient_inventory} item(s) out of stock`);
        }
        if (errorCounts.version_conflict) {
          errorMessages.push(`${errorCounts.version_conflict} item(s) had version conflicts`);
        }
        if (errorCounts.network_error) {
          errorMessages.push(`${errorCounts.network_error} item(s) had network issues`);
        }
        if (errorCounts.max_retries_exceeded) {
          errorMessages.push(`${errorCounts.max_retries_exceeded} item(s) exceeded retry limit`);
        }

        const otherErrors = Object.keys(errorCounts).filter(key =>
          !['insufficient_inventory', 'version_conflict', 'network_error', 'max_retries_exceeded'].includes(key)
        );
        if (otherErrors.length > 0) {
          const otherCount = otherErrors.reduce((sum, key) => sum + errorCounts[key], 0);
          errorMessages.push(`${otherCount} item(s) had other errors`);
        }

        return errorMessages.length > 0 ? `Issues: ${errorMessages.join(', ')}.` : '';
      }

      // Enhanced purchase processing with robust retry logic and exponential backoff
      async function processPurchaseItem(item, maxRetries = 5) {
        let attempt = 0;
        let currentVersion = item.version;
        const baseDelay = 1000; // Base delay of 1 second

        console.log(`🛒 Starting purchase process for ${item.productName} (max retries: ${maxRetries})`);

        while (attempt < maxRetries) {
          attempt++;

          try {
            // Generate unique idempotency key for each attempt
            const idempotencyKey = generateUUID();

            // Create purchase request (negative delta to reduce inventory)
            const purchaseRequest = {
              storeId: STORE_ID,
              productId: item.productId,
              delta: -item.quantity, // Negative to reduce inventory
              version: currentVersion,
              idempotencyKey: idempotencyKey
            };

            console.log(`🔄 Purchase attempt ${attempt}/${maxRetries} for ${item.productName}:`, purchaseRequest);

            // Send purchase request to Store API with timeout
            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), 10000); // 10 second timeout

            const response = await fetch('/api/inventory/updates', {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json',
                'X-API-Key': API_KEY
              },
              body: JSON.stringify(purchaseRequest),
              signal: controller.signal
            });

            clearTimeout(timeoutId);

            // Handle different response scenarios
            let responseData;
            try {
              responseData = await response.json();
            } catch (jsonError) {
              console.error(`❌ Failed to parse JSON response for ${item.productName}:`, jsonError);
              throw new Error(`Invalid JSON response: ${response.status} ${response.statusText}`);
            }

            // Success case
            if (response.ok && responseData.applied) {
              console.log(`✅ Purchase successful for ${item.productName} on attempt ${attempt}:`, responseData);
              return {
                success: true,
                productId: item.productId,
                productName: item.productName,
                quantity: item.quantity,
                newQuantity: responseData.newQuantity,
                newVersion: responseData.newVersion,
                attempt: attempt,
                totalAttempts: attempt
              };
            }

            // Enhanced error type detection
            const errorType = detectErrorType(response, responseData);
            const errorMessage = responseData.errorMessage || responseData.message || `HTTP ${response.status}`;

            console.log(`⚠️ Purchase attempt ${attempt} failed for ${item.productName}:`, {
              status: response.status,
              detectedErrorType: errorType,
              originalErrorType: responseData.errorType,
              errorMessage,
              fullResponse: responseData
            });

            // Version conflict - extract version from error response for immediate retry
            if (errorType === 'version_conflict') {
              console.log(`🔄 Version conflict detected for ${item.productName}, extracting version from error response...`);

              // Extract version information from error response
              const versionInfo = extractVersionFromErrorResponse(responseData);

              // Validate the extracted version information
              const validation = validateVersionInfo(versionInfo, currentVersion);

              if (validation.isValid) {
                const oldVersion = currentVersion;
                currentVersion = validation.newVersion;
                console.log(`📝 Successfully extracted and validated version for ${item.productName}: ${oldVersion} → ${currentVersion}`);

                // Check if inventory information is available and sufficient
                if (validation.newQuantity !== null && validation.newQuantity < item.quantity) {
                  console.log(`❌ Insufficient inventory from error response for ${item.productName}: available=${validation.newQuantity}, requested=${item.quantity}`);
                  return {
                    success: false,
                    productId: item.productId,
                    productName: item.productName,
                    error: 'insufficient_inventory',
                    message: `Insufficient inventory after version conflict. Available: ${validation.newQuantity}, Requested: ${item.quantity}`,
                    attempt: attempt,
                    totalAttempts: attempt,
                    extractedFromErrorResponse: true
                  };
                }

                // Calculate exponential backoff delay for version conflicts
                const delay = Math.min(baseDelay * Math.pow(2, attempt - 1), 8000); // Max 8 seconds
                console.log(`⏳ Waiting ${delay}ms before retry with extracted version...`);
                await new Promise(resolve => setTimeout(resolve, delay));

                // Continue to next attempt with updated version from error response
                continue;
              } else {
                // Fallback: fetch current product data if version extraction fails
                console.log(`⚠️ Version extraction failed (${validation.reason}), falling back to API fetch...`);

                const currentProduct = await fetchCurrentProductDataWithRetry(item.productId, 2);

                if (currentProduct && currentProduct.version) {
                  const oldVersion = currentVersion;
                  currentVersion = currentProduct.version;
                  console.log(`📝 Fallback: Updated version for ${item.productName}: ${oldVersion} → ${currentVersion}`);

                  // Check inventory
                  if (currentProduct.available < item.quantity) {
                    console.log(`❌ Insufficient inventory after fallback fetch for ${item.productName}: available=${currentProduct.available}, requested=${item.quantity}`);
                    return {
                      success: false,
                      productId: item.productId,
                      productName: item.productName,
                      error: 'insufficient_inventory',
                      message: `Insufficient inventory after version conflict. Available: ${currentProduct.available}, Requested: ${item.quantity}`,
                      attempt: attempt,
                      totalAttempts: attempt,
                      usedFallback: true
                    };
                  }

                  // Continue with fallback version
                  const delay = Math.min(baseDelay * Math.pow(2, attempt - 1), 8000);
                  console.log(`⏳ Waiting ${delay}ms before retry with fallback version...`);
                  await new Promise(resolve => setTimeout(resolve, delay));
                  continue;
                } else {
                  console.error(`❌ Version extraction failed (${validation.reason}) and fallback fetch failed for ${item.productName}`);
                  return {
                    success: false,
                    productId: item.productId,
                    productName: item.productName,
                    error: 'version_resolution_failed',
                    message: `Version conflict resolution failed: ${validation.reason}. Fallback API fetch also failed.`,
                    attempt: attempt,
                    totalAttempts: attempt,
                    extractionFailureReason: validation.reason
                  };
                }
              }
            }

            // Non-retryable errors - return immediately
            if (errorType === 'insufficient_inventory') {
              console.log(`❌ Insufficient inventory for ${item.productName} - not retrying`);
              return {
                success: false,
                productId: item.productId,
                productName: item.productName,
                error: 'insufficient_inventory',
                message: errorMessage,
                attempt: attempt,
                totalAttempts: attempt
              };
            }

            // Server errors (5xx) - retry with exponential backoff
            if (response.status >= 500) {
              console.log(`🔄 Server error (${response.status}) for ${item.productName} - will retry`);
              const delay = Math.min(baseDelay * Math.pow(2, attempt - 1), 8000);
              console.log(`⏳ Waiting ${delay}ms before retry due to server error...`);
              await new Promise(resolve => setTimeout(resolve, delay));
              continue;
            }

            // Client errors (4xx except 409) - usually not retryable
            if (response.status >= 400 && response.status < 500) {
              console.log(`❌ Client error (${response.status}) for ${item.productName} - not retrying`);
              return {
                success: false,
                productId: item.productId,
                productName: item.productName,
                error: errorType,
                message: errorMessage,
                attempt: attempt,
                totalAttempts: attempt
              };
            }

            // Other errors - retry with backoff
            console.log(`🔄 Unknown error for ${item.productName} - will retry`);
            const delay = Math.min(baseDelay * Math.pow(2, attempt - 1), 8000);
            await new Promise(resolve => setTimeout(resolve, delay));
            continue;

          } catch (error) {
            console.error(`❌ Network/Exception error on attempt ${attempt} for ${item.productName}:`, error);

            // Handle specific error types
            if (error.name === 'AbortError') {
              console.log(`⏰ Request timeout for ${item.productName} on attempt ${attempt}`);
            } else if (error.message && error.message.includes('fetch')) {
              console.log(`🌐 Network error for ${item.productName} on attempt ${attempt}`);
            }

            // If this is the last attempt, return the error
            if (attempt === maxRetries) {
              console.error(`❌ Final attempt failed for ${item.productName}`);
              return {
                success: false,
                productId: item.productId,
                productName: item.productName,
                error: 'network_error',
                message: error.message || 'Network error',
                attempt: attempt,
                totalAttempts: attempt
              };
            }

            // Calculate exponential backoff for network errors
            const delay = Math.min(baseDelay * Math.pow(2, attempt - 1), 8000);
            console.log(`⏳ Waiting ${delay}ms before retry due to network error...`);
            await new Promise(resolve => setTimeout(resolve, delay));
          }
        }

        // Max retries exceeded
        console.error(`❌ Max retries (${maxRetries}) exceeded for ${item.productName}`);
        return {
          success: false,
          productId: item.productId,
          productName: item.productName,
          error: 'max_retries_exceeded',
          message: `Failed after ${maxRetries} attempts`,
          attempt: maxRetries,
          totalAttempts: maxRetries
        };
      }

      // Enhanced product data fetching with retry logic
      async function fetchCurrentProductDataWithRetry(productId, maxRetries = 3) {
        console.log(`📡 Fetching current product data for ${productId} (max retries: ${maxRetries})`);

        for (let attempt = 1; attempt <= maxRetries; attempt++) {
          try {
            console.log(`🔄 Fetch attempt ${attempt}/${maxRetries} for product ${productId}`);

            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), 5000); // 5 second timeout

            const response = await fetch(`/api/inventory/${productId}`, {
              headers: {
                'X-API-Key': API_KEY
              },
              signal: controller.signal
            });

            clearTimeout(timeoutId);

            if (response.ok) {
              const product = await response.json();
              console.log(`✅ Successfully fetched current data for ${productId}:`, {
                version: product.version,
                available: product.available
              });
              return product;
            } else {
              console.error(`❌ Failed to fetch current data for ${productId} on attempt ${attempt}:`, response.status);

              // If this is the last attempt or it's a client error, don't retry
              if (attempt === maxRetries || (response.status >= 400 && response.status < 500)) {
                return null;
              }

              // Wait before retry for server errors
              const delay = 1000 * attempt;
              console.log(`⏳ Waiting ${delay}ms before retry...`);
              await new Promise(resolve => setTimeout(resolve, delay));
            }
          } catch (error) {
            console.error(`❌ Error fetching current data for ${productId} on attempt ${attempt}:`, error);

            if (attempt === maxRetries) {
              return null;
            }

            // Wait before retry
            const delay = 1000 * attempt;
            console.log(`⏳ Waiting ${delay}ms before retry due to error...`);
            await new Promise(resolve => setTimeout(resolve, delay));
          }
        }

        console.error(`❌ Failed to fetch current data for ${productId} after ${maxRetries} attempts`);
        return null;
      }

      // Legacy function for backward compatibility
      async function fetchCurrentProductData(productId) {
        return await fetchCurrentProductDataWithRetry(productId, 1);
      }

      // Extract version information from error response
      function extractVersionFromErrorResponse(responseData) {
        console.log(`🔍 Extracting version from error response:`, responseData);

        try {
          // Initialize result object
          const result = {
            newVersion: null,
            newQuantity: null,
            productId: null,
            errorType: null,
            errorMessage: null
          };

          // Method 1: Direct fields in response (simple format)
          if (responseData.newVersion) {
            result.newVersion = responseData.newVersion;
            result.newQuantity = responseData.newQuantity;
            result.productId = responseData.productId;
            result.errorType = responseData.errorType;
            result.errorMessage = responseData.errorMessage;
            console.log(`✅ Extracted version from direct fields:`, result);
            return result;
          }

          // Method 2: Nested in error object (complex format)
          if (responseData.error && responseData.error.details) {
            const details = responseData.error.details;

            // Check if details contains a JSON string that needs parsing
            if (typeof details.error === 'string') {
              try {
                // Parse the nested JSON string
                const nestedData = JSON.parse(details.error.split('status 409: ')[1].split('\\n')[0]);
                result.newVersion = nestedData.newVersion;
                result.newQuantity = nestedData.newQuantity;
                result.productId = nestedData.productId || details.productId;
                result.errorType = nestedData.errorType;
                result.errorMessage = nestedData.errorMessage;
                console.log(`✅ Extracted version from nested JSON:`, result);
                return result;
              } catch (parseError) {
                console.warn(`⚠️ Failed to parse nested JSON in error details:`, parseError);
              }
            }

            // Check if details has direct fields
            if (details.newVersion) {
              result.newVersion = details.newVersion;
              result.newQuantity = details.newQuantity;
              result.productId = details.productId;
              result.errorType = details.errorType;
              result.errorMessage = details.errorMessage;
              console.log(`✅ Extracted version from error details:`, result);
              return result;
            }
          }

          // Method 3: Look for version in error message patterns
          const errorMessage = responseData.errorMessage || responseData.message || '';

          // Pattern: "version conflict: expected X, got Y"
          const versionPattern = /version conflict: expected (\d+), got (\d+)/i;
          const versionMatch = errorMessage.match(versionPattern);

          if (versionMatch) {
            result.newVersion = parseInt(versionMatch[1], 10); // Expected version
            result.errorType = 'version_conflict';
            result.errorMessage = errorMessage;
            console.log(`✅ Extracted version from error message pattern:`, result);
            return result;
          }

          // Method 4: Look for JSON embedded in error message
          const jsonPattern = /\{[^}]*"newVersion"\s*:\s*(\d+)[^}]*\}/i;
          const jsonMatch = errorMessage.match(jsonPattern);

          if (jsonMatch) {
            try {
              const embeddedJson = JSON.parse(jsonMatch[0]);
              result.newVersion = embeddedJson.newVersion;
              result.newQuantity = embeddedJson.newQuantity;
              result.productId = embeddedJson.productId;
              result.errorType = embeddedJson.errorType;
              result.errorMessage = embeddedJson.errorMessage;
              console.log(`✅ Extracted version from embedded JSON:`, result);
              return result;
            } catch (parseError) {
              console.warn(`⚠️ Failed to parse embedded JSON:`, parseError);
            }
          }

          console.warn(`⚠️ Could not extract version information from error response`);
          return result;

        } catch (error) {
          console.error(`❌ Error while extracting version from response:`, error);
          return {
            newVersion: null,
            newQuantity: null,
            productId: null,
            errorType: null,
            errorMessage: null
          };
        }
      }

      // Validate and sanitize extracted version information
      function validateVersionInfo(versionInfo, currentVersion) {
        if (!versionInfo || typeof versionInfo !== 'object') {
          return { isValid: false, reason: 'Invalid version info object' };
        }

        // Check if newVersion is a valid number
        if (versionInfo.newVersion === null || versionInfo.newVersion === undefined) {
          return { isValid: false, reason: 'No version information found' };
        }

        const newVersion = parseInt(versionInfo.newVersion, 10);
        if (isNaN(newVersion) || newVersion < 1) {
          return { isValid: false, reason: `Invalid version number: ${versionInfo.newVersion}` };
        }

        // Check if the new version is actually different from current
        if (newVersion === currentVersion) {
          return { isValid: false, reason: `New version (${newVersion}) is same as current version (${currentVersion})` };
        }

        // Validate quantity if provided
        if (versionInfo.newQuantity !== null && versionInfo.newQuantity !== undefined) {
          const newQuantity = parseInt(versionInfo.newQuantity, 10);
          if (isNaN(newQuantity) || newQuantity < 0) {
            return { isValid: false, reason: `Invalid quantity: ${versionInfo.newQuantity}` };
          }
        }

        return {
          isValid: true,
          newVersion: newVersion,
          newQuantity: versionInfo.newQuantity !== null ? parseInt(versionInfo.newQuantity, 10) : null
        };
      }

      // Enhanced error type detection
      function detectErrorType(response, responseData) {
        // Check HTTP status first
        if (response.status === 409) {
          return 'version_conflict';
        }

        // Check explicit error type in response
        if (responseData.errorType) {
          return responseData.errorType;
        }

        // Check nested error type
        if (responseData.error && responseData.error.details && responseData.error.details.errorType) {
          return responseData.error.details.errorType;
        }

        // Check error code
        if (responseData.error && responseData.error.code) {
          const code = responseData.error.code.toLowerCase();
          if (code.includes('version') || code.includes('conflict')) {
            return 'version_conflict';
          }
          if (code.includes('inventory') || code.includes('stock')) {
            return 'insufficient_inventory';
          }
          if (code.includes('update_failed')) {
            // For generic update_failed, try to determine from message
            const message = (responseData.error.message || '').toLowerCase();
            if (message.includes('version conflict')) {
              return 'version_conflict';
            }
            if (message.includes('insufficient') || message.includes('stock')) {
              return 'insufficient_inventory';
            }
          }
        }

        // Check error message patterns
        const errorMessage = (responseData.errorMessage || responseData.message || '').toLowerCase();
        if (errorMessage.includes('version conflict')) {
          return 'version_conflict';
        }
        if (errorMessage.includes('insufficient') || errorMessage.includes('stock')) {
          return 'insufficient_inventory';
        }

        // Default based on HTTP status
        if (response.status >= 500) {
          return 'server_error';
        }
        if (response.status >= 400) {
          return 'client_error';
        }

        return 'unknown_error';
      }

      // Update last update time
      function updateTime() {
        document.getElementById('last-update').textContent = new Date().toLocaleTimeString();
      }

      // Auto-refresh functionality - refreshes products every 5 seconds
      function startAutoRefresh() {
        if (autoRefreshInterval) {
          clearInterval(autoRefreshInterval);
        }

        if (!autoRefreshEnabled) {
          console.log('🔄 Auto-refresh is disabled');
          return;
        }

        console.log(`🔄 Starting auto-refresh every ${AUTO_REFRESH_INTERVAL_MS / 1000} seconds`);

        autoRefreshInterval = setInterval(() => {
          if (!isLoading && autoRefreshEnabled) {
            console.log('🔄 Auto-refreshing products...');
            loadProducts(true); // Silent refresh
          } else if (isLoading) {
            console.log('⏳ Skipping auto-refresh - already loading');
          }
        }, AUTO_REFRESH_INTERVAL_MS);
      }

      function stopAutoRefresh() {
        if (autoRefreshInterval) {
          console.log('⏹️ Stopping auto-refresh');
          clearInterval(autoRefreshInterval);
          autoRefreshInterval = null;
        }
      }

      function toggleAutoRefresh() {
        autoRefreshEnabled = !autoRefreshEnabled;
        updateAutoRefreshUI();

        if (autoRefreshEnabled) {
          startAutoRefresh();
          showMessage('🔄 Auto-refresh enabled (every 5 seconds)', 'success');
        } else {
          stopAutoRefresh();
          showMessage('⏸️ Auto-refresh paused', 'warning');
        }

        console.log(`🔄 Auto-refresh ${autoRefreshEnabled ? 'enabled' : 'disabled'}`);
      }

      function updateAutoRefreshUI() {
        const toggleBtn = document.getElementById('auto-refresh-toggle');
        const statusEl = document.getElementById('auto-refresh-status');

        if (autoRefreshEnabled) {
          if (toggleBtn) toggleBtn.textContent = '⏸️ Pause Auto-Refresh';
          if (statusEl) statusEl.textContent = '🔄 Active (5s)';
        } else {
          if (toggleBtn) toggleBtn.textContent = '▶️ Resume Auto-Refresh';
          if (statusEl) statusEl.textContent = '⏸️ Paused';
        }
      }

      // Update last refresh display
      function updateLastRefreshDisplay() {
        const displayEl = document.getElementById('last-update-display');

        if (!lastRefreshTime) {
          displayEl.textContent = 'Last Update: Never';
          return;
        }

        // Format the date and time in a user-friendly way
        const now = new Date();
        const diffMs = now - lastRefreshTime;
        const diffSeconds = Math.floor(diffMs / 1000);
        const diffMinutes = Math.floor(diffSeconds / 60);
        const diffHours = Math.floor(diffMinutes / 60);

        let timeAgo;
        if (diffSeconds < 60) {
          timeAgo = 'just now';
        } else if (diffMinutes < 60) {
          timeAgo = `${diffMinutes} minute${diffMinutes !== 1 ? 's' : ''} ago`;
        } else if (diffHours < 24) {
          timeAgo = `${diffHours} hour${diffHours !== 1 ? 's' : ''} ago`;
        } else {
          // For older updates, show the actual date and time
          timeAgo = lastRefreshTime.toLocaleDateString() + ' at ' +
                   lastRefreshTime.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
        }

        displayEl.textContent = `Last Update: ${timeAgo}`;
      }

      // Test API connectivity
      async function testAPI() {
        const statusEl = document.getElementById('api-status');
        statusEl.textContent = '🔄 Testing...';

        try {
          const response = await fetch('/api/inventory', {
            headers: {
              'X-API-Key': API_KEY
            }
          });

          if (response.ok) {
            statusEl.textContent = '✅ Connected';
            showMessage('API connection successful!', 'success');
          } else {
            statusEl.textContent = '❌ Error ' + response.status;
            showMessage('API connection failed: ' + response.status, 'error');
          }
        } catch (error) {
          statusEl.textContent = '❌ Failed';
          showMessage('API connection error: ' + error.message, 'error');
        }

        updateTime();
      }

      // Load products with pagination support
      async function loadProducts(silent = false) {
        if (isLoading) return;

        isLoading = true;
        const contentEl = document.getElementById('products-content');

        if (!silent) {
          contentEl.innerHTML = '<div class="loading"><div class="spinner"></div><p>Loading products...</p></div>';
        } else {
          contentEl.classList.add('refreshing');
        }

        try {
          // Use offset-based pagination with limit parameter
          const url = `/api/inventory?offset=${(currentPage - 1) * productsPerPage}&limit=${productsPerPage}`;
          const response = await fetch(url, {
            headers: {
              'X-API-Key': API_KEY
            }
          });

          if (response.ok) {
            const data = await response.json();
            console.log('API Response received:', data); // Debug log

            // Handle different response formats
            if (data.products && data.pagination) {
              // New pagination format (Central API and updated Store S1 API)
              console.log('Using pagination format'); // Debug log
              allProducts = data.products || [];
              totalProducts = data.pagination.total_count || 0;

              // Update pagination info from server response
              const serverOffset = data.pagination.offset || 0;
              const serverLimit = data.pagination.limit || productsPerPage;
              currentPage = Math.floor(serverOffset / serverLimit) + 1;
            } else if (Array.isArray(data)) {
              // Direct array format (legacy Store S1 API)
              console.log('Using direct array format'); // Debug log
              allProducts = data || [];
              totalProducts = allProducts.length;

              // For direct array, we need to handle pagination client-side
              const startIndex = (currentPage - 1) * productsPerPage;
              const endIndex = startIndex + productsPerPage;
              allProducts = allProducts.slice(startIndex, endIndex);
            } else {
              // Fallback for unknown format
              console.warn('Unknown response format:', data);
              allProducts = [];
              totalProducts = 0;
            }

            console.log('Processed products:', allProducts.length, 'Total:', totalProducts); // Debug log

            // Reset to page 1 if current page is beyond available pages
            const maxPages = Math.ceil(totalProducts / productsPerPage);
            if (currentPage > maxPages && maxPages > 0) {
              currentPage = 1;
            }

            displayCurrentPage();
            updatePaginationControls();

            // Update last refresh timestamp
            lastRefreshTime = new Date();
            updateLastRefreshDisplay();

            if (!silent) {
              showMessage(`Loaded ${totalProducts} products successfully!`, 'success');
            }

            // Update API status
            document.getElementById('api-status').textContent = '✅ Connected';
          } else {
            contentEl.innerHTML = '<p>❌ Failed to load products: ' + response.status + '</p>';
            if (!silent) {
              showMessage('Failed to load products: ' + response.status, 'error');
            }
            document.getElementById('api-status').textContent = '❌ Error ' + response.status;
          }
        } catch (error) {
          console.error('Failed to load products:', error);

          // Parse structured error response
          let errorMessage = 'Unknown error occurred';
          let errorCode = 'unknown_error';

          try {
            // Try to parse as structured error response
            if (error.message && error.message.includes('{')) {
              const errorData = JSON.parse(error.message.substring(error.message.indexOf('{')));
              if (errorData.error) {
                errorCode = errorData.error.code || 'unknown_error';
                errorMessage = errorData.error.message || errorMessage;

                // Add specific handling for different error types
                switch (errorCode) {
                  case 'storage_error':
                    errorMessage = 'Storage system is temporarily unavailable';
                    break;
                  case 'product_not_found':
                    errorMessage = 'Product not found in inventory';
                    break;
                  case 'version_conflict':
                    errorMessage = 'Version conflict - data may be outdated';
                    break;
                  case 'insufficient_inventory':
                    errorMessage = 'Insufficient inventory for this operation';
                    break;
                  default:
                    // Use the provided message
                    break;
                }
              }
            } else {
              errorMessage = error.message || errorMessage;
            }
          } catch (parseError) {
            // Fallback to original error message
            errorMessage = error.message || errorMessage;
          }

          contentEl.innerHTML = `<p>❌ Error loading products: ${errorMessage}</p>`;
          if (!silent) {
            showMessage(`Error loading products: ${errorMessage}`, 'error');
          }
          document.getElementById('api-status').textContent = '❌ Failed';
        } finally {
          isLoading = false;
          contentEl.classList.remove('refreshing');
          updateTime();
        }
      }

      // Display current page of products
      function displayCurrentPage() {
        const contentEl = document.getElementById('products-content');

        if (!allProducts || allProducts.length === 0) {
          contentEl.innerHTML = '<p>No products found</p>';
          document.getElementById('pagination-controls').style.display = 'none';
          return;
        }

        // Products are already paginated by the server, so use them directly
        const currentProducts = allProducts;

        // Display products
        let html = '<div class="product-grid">';

        currentProducts.forEach(product => {
          const stockStatus = getStockStatus(product.available);
          const stockColor = getStockColor(product.available);

          // Handle different date field formats
          const dateField = product.lastUpdated || product.last_updated || product.LastUpdated;
          const formattedDate = formatDate(dateField);

          // Handle different name and ID field formats
          const productName = product.name || product.Name || 'Unknown Product';
          const productId = product.productId || product.product_id || product.ProductID || 'Unknown ID';

          // Handle version field - ensure it's a number
          let version = product.version || product.Version || 1;
          if (typeof version !== 'number' || isNaN(version)) {
            version = 1; // Default to version 1 if invalid
          }

          // Handle available field
          const available = product.available !== undefined ? product.available :
                           (product.Available !== undefined ? product.Available : 0);

          // Use real price from API response
          const price = product.price || 0;

          // Validate price
          if (typeof price !== 'number' || isNaN(price) || price < 0) {
            console.warn(`Invalid price for product ${productId}:`, price);
          }

          // Debug log for the fifth product (index 4)
          const productIndex = currentProducts.indexOf(product);
          if (productIndex === 4) {
            console.log('🔍 Fifth product data (index 4):', {
              productIndex,
              productId,
              productName,
              price,
              available,
              version,
              rawProduct: product
            });
          }

          html += `
            <div class="product-card">
              <div class="product-header">
                <h3>${productName}</h3>
              </div>
              <p><strong>Available:</strong> <span style="color: ${stockColor};">${available} ${stockStatus}</span></p>
              <p><strong>Price:</strong> $${price.toFixed(2)}</p>
              <button class="btn add-to-cart-btn"
                      ${available <= 0 || price <= 0 ? 'disabled' : ''}
                      data-product-id="${productId}"
                      data-product-name="${productName}"
                      data-price="${price}"
                      data-available="${available}"
                      data-version="${version}">
                🛒 Add to Cart
              </button>
            </div>
          `;
        });

        html += '</div>';
        contentEl.innerHTML = html;

        // Add event listeners to add-to-cart buttons
        attachAddToCartListeners();

        // Show pagination controls
        const paginationEl = document.getElementById('pagination-controls');
        if (paginationEl) {
          paginationEl.style.display = 'flex';
        }
      }

      // Function to attach event listeners to add-to-cart buttons
      function attachAddToCartListeners() {
        const addToCartButtons = document.querySelectorAll('.add-to-cart-btn');
        console.log(`🔧 Attaching event listeners to ${addToCartButtons.length} buttons`);

        addToCartButtons.forEach((button, index) => {
          // Skip if already has event listener
          if (button._hasEventListener) {
            console.log(`⏭️ Button ${index + 1} already has event listener`);
            return;
          }

          // Mark as having event listener
          button._hasEventListener = true;

          button.addEventListener('click', function(e) {
            e.preventDefault();
            e.stopPropagation();

            console.log(`🖱️ Button ${index + 1} clicked`);

            // Get data from button attributes
            const productId = this.getAttribute('data-product-id');
            const productName = this.getAttribute('data-product-name');
            const price = parseFloat(this.getAttribute('data-price'));
            const available = parseInt(this.getAttribute('data-available'));
            const version = parseInt(this.getAttribute('data-version')) || 1;

            // Debug log for fifth product (index 4)
            if (index === 4) {
              console.log('🎯 Fifth product button clicked:', {
                index,
                productId,
                productName,
                price,
                available,
                version,
                buttonElement: this,
                disabled: this.disabled
              });
            }

            // Check if button is disabled
            if (this.disabled) {
              console.log('❌ Button is disabled, not adding to cart');
              return;
            }

            // Validate data before calling addToCart
            if (!productId || !productName || isNaN(price) || isNaN(available)) {
              console.error('❌ Invalid product data from button:', {
                productId,
                productName,
                price,
                available,
                version
              });
              showMessage('Error: Invalid product data', 'error');
              return;
            }

            console.log(`✅ Calling addToCart for button ${index + 1}`);
            // Call addToCart function
            addToCart(productId, productName, price, available, version);
          });

          console.log(`✅ Event listener attached to button ${index + 1} (${button.dataset.productName})`);
        });

        console.log(`🎉 Completed attaching event listeners to ${addToCartButtons.length} buttons`);
      }

      // Get stock status text
      function getStockStatus(available) {
        if (available === 0) return '(Out of Stock)';
        if (available <= 5) return '(Low Stock)';
        return '(In Stock)';
      }

      // Get stock color
      function getStockColor(available) {
        if (available === 0) return '#e74c3c';
        if (available <= 5) return '#f39c12';
        return '#27ae60';
      }

      // Helper function to format dates
      function formatDate(dateString) {
        if (!dateString) return 'Never updated';

        try {
          const date = new Date(dateString);

          // Check if date is valid
          if (isNaN(date.getTime())) {
            return 'Invalid date';
          }

          // Format as "Jan 15, 2024 at 10:30 AM"
          const options = {
            year: 'numeric',
            month: 'short',
            day: 'numeric',
            hour: '2-digit',
            minute: '2-digit',
            hour12: true
          };

          return date.toLocaleDateString('en-US', options);
        } catch (error) {
          console.warn('Error formatting date:', dateString, error);
          return 'Unknown';
        }
      }

      // Update pagination controls
      function updatePaginationControls() {
        const totalPages = Math.ceil(totalProducts / productsPerPage);
        const startItem = totalProducts === 0 ? 0 : (currentPage - 1) * productsPerPage + 1;
        const endItem = Math.min(currentPage * productsPerPage, totalProducts);

        document.getElementById('page-info').textContent = `Page ${currentPage} of ${totalPages}`;
        document.getElementById('total-info').textContent = `(${startItem}-${endItem} of ${totalProducts} products)`;

        document.getElementById('prev-btn').disabled = currentPage <= 1;
        document.getElementById('next-btn').disabled = currentPage >= totalPages;
      }

      // Navigation functions
      function previousPage() {
        if (currentPage > 1) {
          currentPage--;
          loadProducts(true); // Reload data for new page
        }
      }

      function nextPage() {
        const totalPages = Math.ceil(totalProducts / productsPerPage);
        if (currentPage < totalPages) {
          currentPage++;
          loadProducts(true); // Reload data for new page
        }
      }

      // Test health
      async function testHealth() {
        try {
          const response = await fetch('/health');
          if (response.ok) {
            showMessage('Health check passed!', 'success');
          } else {
            showMessage('Health check failed: ' + response.status, 'error');
          }
        } catch (error) {
          showMessage('Health check error: ' + error.message, 'error');
        }
        updateTime();
      }

      // Show message
      function showMessage(message, type) {
        const existing = document.querySelector('.message');
        if (existing) existing.remove();

        const div = document.createElement('div');
        div.className = 'message ' + type;
        div.innerHTML = `<p>${message}</p>`;
        document.querySelector('.container').appendChild(div);

        setTimeout(() => div.remove(), 5000);
      }

      // Auto-refresh toggle functionality removed

      // Initialize dynamic content based on environment variables
      function initializeDynamicContent() {
        // Update page title
        document.title = `${STORE_NAME} - Inventory Management`;

        // Update store title in header
        const storeTitle = document.getElementById('store-title');
        if (storeTitle) {
          storeTitle.textContent = `🏪 ${STORE_NAME} Inventory`;
        }

        // Update store API label
        const storeApiLabel = document.getElementById('store-api-label');
        if (storeApiLabel) {
          storeApiLabel.textContent = `${STORE_NAME} API:`;
        }

        // Update test API button
        const testApiBtn = document.getElementById('test-api-btn');
        if (testApiBtn) {
          testApiBtn.textContent = `🔄 Test ${STORE_NAME} API`;
        }

        // Update meta description
        const metaDescription = document.querySelector('meta[name="description"]');
        if (metaDescription) {
          metaDescription.setAttribute('content', `${STORE_NAME} Inventory Management Frontend`);
        }
      }

      // Initialize application
      function initializeApp() {
        // Initialize dynamic content first
        initializeDynamicContent();

        // Add global error handler for debugging
        window.addEventListener('error', function(e) {
          console.error('Global error:', e.error, e.message, e.filename, e.lineno);
        });

        // Add global click event listener for debugging
        document.addEventListener('click', function(e) {
          if (e.target.classList.contains('add-to-cart-btn')) {
            console.log('🖱️ Global click detected on add-to-cart button:', {
              productId: e.target.dataset.productId,
              productName: e.target.dataset.productName,
              price: e.target.dataset.price,
              available: e.target.dataset.available,
              version: e.target.dataset.version,
              disabled: e.target.disabled,
              classList: Array.from(e.target.classList)
            });
          }
        });

        // Add specific debugging for fifth product
        window.debugFifthProduct = function() {
          const buttons = document.querySelectorAll('.add-to-cart-btn');
          console.log('🔍 All add-to-cart buttons:', buttons.length);

          buttons.forEach((button, index) => {
            console.log(`Button ${index + 1}:`, {
              index,
              productId: button.dataset.productId,
              productName: button.dataset.productName,
              disabled: button.disabled,
              hasEventListener: button._hasEventListener || false
            });

            if (index === 4) { // Fifth product (index 4)
              console.log('🎯 Fifth product button details:', {
                element: button,
                outerHTML: button.outerHTML,
                allDataAttributes: Object.keys(button.dataset),
                computedStyle: window.getComputedStyle(button).display
              });
            }
          });
        };

        updateTime();
        setInterval(updateTime, 1000);

        // Initialize cart display
        updateCartDisplay();

        // Initialize last refresh display
        updateLastRefreshDisplay();

        // Initialize auto-refresh UI
        updateAutoRefreshUI();

        // Update last refresh display every 30 seconds
        setInterval(updateLastRefreshDisplay, 30000);

        // Auto-load products on page load
        setTimeout(() => {
          loadProducts();
          testAPI();

          // Start auto-refresh after initial load
          setTimeout(() => {
            startAutoRefresh();
          }, 1000);
        }, 500);

        // Fallback: Force load after 2 seconds if nothing is displayed
        setTimeout(() => {
          const contentEl = document.getElementById('products-content');
          if (contentEl && contentEl.innerHTML.includes('Loading products...')) {
            console.warn('Fallback: Retrying product load...');
            loadProducts();
          }
        }, 2000);
      }

      // Initialize when DOM is ready
      function ensureInitialization() {
        if (document.readyState === 'loading') {
          document.addEventListener('DOMContentLoaded', initializeApp);
        } else if (document.readyState === 'interactive' || document.readyState === 'complete') {
          // DOM is ready, but let's wait a bit more to ensure all elements are rendered
          setTimeout(initializeApp, 100);
        } else {
          // Fallback
          setTimeout(ensureInitialization, 100);
        }
      }

      // Start initialization
      ensureInitialization();
    </script>
  </body>
</html>
