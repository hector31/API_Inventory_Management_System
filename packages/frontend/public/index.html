<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="theme-color" content="#000000" />
    <meta name="description" content="Store S1 Inventory Management Frontend" />
    <title>Store S1 - Inventory Management</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen',
          'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue',
          sans-serif;
        -webkit-font-smoothing: antialiased;
        -moz-osx-font-smoothing: grayscale;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        min-height: 100vh;
        padding: 2rem;
      }

      .container {
        max-width: 1200px;
        margin: 0 auto;
        background: rgba(255,255,255,0.1);
        border-radius: 12px;
        padding: 2rem;
        backdrop-filter: blur(10px);
      }

      .header {
        text-align: center;
        margin-bottom: 2rem;
      }

      .header h1 {
        font-size: 2.5rem;
        margin-bottom: 0.5rem;
      }

      .header p {
        font-size: 1.2rem;
        opacity: 0.9;
      }

      .status {
        background: rgba(255,255,255,0.2);
        border-radius: 8px;
        padding: 1.5rem;
        margin-bottom: 2rem;
      }

      .status h2 {
        margin-bottom: 1rem;
        color: #fff;
      }

      .status-item {
        display: flex;
        justify-content: space-between;
        margin-bottom: 0.5rem;
        padding: 0.5rem;
        background: rgba(255,255,255,0.1);
        border-radius: 4px;
      }

      .btn {
        background: #3498db;
        color: white;
        border: none;
        padding: 1rem 2rem;
        border-radius: 6px;
        cursor: pointer;
        font-size: 1rem;
        margin: 0.5rem;
        transition: all 0.2s;
      }

      .btn:hover {
        background: #2980b9;
        transform: translateY(-1px);
      }

      .products {
        background: rgba(255,255,255,0.2);
        border-radius: 8px;
        padding: 1.5rem;
        margin-top: 2rem;
      }

      .loading {
        text-align: center;
        padding: 2rem;
      }

      .spinner {
        border: 4px solid rgba(255,255,255,0.3);
        border-top: 4px solid #fff;
        border-radius: 50%;
        width: 40px;
        height: 40px;
        animation: spin 2s linear infinite;
        margin: 0 auto 1rem;
      }

      @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
      }

      .error {
        background: rgba(231, 76, 60, 0.2);
        border: 1px solid rgba(231, 76, 60, 0.5);
        border-radius: 6px;
        padding: 1rem;
        margin: 1rem 0;
      }

      .success {
        background: rgba(46, 204, 113, 0.2);
        border: 1px solid rgba(46, 204, 113, 0.5);
        border-radius: 6px;
        padding: 1rem;
        margin: 1rem 0;
      }

      .products-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 1rem;
        flex-wrap: wrap;
        gap: 1rem;
      }

      .auto-refresh-controls {
        display: flex;
        align-items: center;
        gap: 1rem;
        background: rgba(255,255,255,0.1);
        padding: 0.5rem 1rem;
        border-radius: 20px;
        font-size: 0.9rem;
      }

      .refresh-toggle {
        display: flex;
        align-items: center;
        gap: 0.5rem;
        cursor: pointer;
      }

      .refresh-toggle input[type="checkbox"] {
        width: 16px;
        height: 16px;
      }

      .countdown {
        background: rgba(255,255,255,0.2);
        padding: 0.2rem 0.6rem;
        border-radius: 12px;
        font-weight: bold;
        min-width: 20px;
        text-align: center;
      }

      .pagination {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-top: 1.5rem;
        padding: 1rem;
        background: rgba(255,255,255,0.1);
        border-radius: 8px;
      }

      .pagination-btn {
        background: rgba(255,255,255,0.2);
        border: 1px solid rgba(255,255,255,0.3);
        color: white;
        padding: 0.5rem 1rem;
        border-radius: 6px;
        cursor: pointer;
        transition: all 0.2s;
        font-size: 0.9rem;
      }

      .pagination-btn:hover:not(:disabled) {
        background: rgba(255,255,255,0.3);
        transform: translateY(-1px);
      }

      .pagination-btn:disabled {
        opacity: 0.5;
        cursor: not-allowed;
        transform: none;
      }

      .pagination-info {
        text-align: center;
        display: flex;
        flex-direction: column;
        gap: 0.2rem;
      }

      .pagination-info span {
        font-size: 0.9rem;
      }

      #total-info {
        opacity: 0.8;
        font-size: 0.8rem;
      }

      .product-grid {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
        gap: 1rem;
        margin: 1rem 0;
      }

      .product-card {
        background: rgba(255,255,255,0.1);
        border-radius: 8px;
        padding: 1rem;
        border: 1px solid rgba(255,255,255,0.2);
        transition: all 0.3s;
      }

      .product-card:hover {
        background: rgba(255,255,255,0.15);
        transform: translateY(-2px);
        box-shadow: 0 4px 20px rgba(0,0,0,0.2);
      }

      .product-card h3 {
        margin-bottom: 0.5rem;
        color: #fff;
        font-size: 1.1rem;
      }

      .product-header {
        margin-bottom: 15px;
        border-bottom: 1px solid rgba(255,255,255,0.2);
        padding-bottom: 10px;
      }

      .product-header h3 {
        margin: 0 0 5px 0;
        color: #fff;
        font-size: 1.2em;
      }

      .product-id {
        color: rgba(255,255,255,0.7);
        font-size: 0.85em;
        font-style: italic;
        display: block;
        margin-top: 2px;
      }

      .product-card p {
        margin-bottom: 0.3rem;
        font-size: 0.9rem;
      }

      .product-card strong {
        color: #fff;
      }

      .loading-overlay {
        position: relative;
      }

      .loading-overlay::after {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0,0,0,0.3);
        border-radius: 8px;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .refreshing {
        opacity: 0.7;
        transition: opacity 0.3s;
      }

      /* Shopping Cart Styles */
      .cart-btn {
        background: #28a745 !important;
        position: relative;
      }

      .cart-sidebar {
        position: fixed;
        top: 0;
        right: -400px;
        width: 400px;
        height: 100vh;
        background: white;
        box-shadow: -2px 0 10px rgba(0,0,0,0.1);
        transition: right 0.3s ease;
        z-index: 1000;
        display: flex;
        flex-direction: column;
      }

      .cart-sidebar.open {
        right: 0;
      }

      .cart-header {
        padding: 20px;
        border-bottom: 1px solid #eee;
        display: flex;
        justify-content: space-between;
        align-items: center;
        background: #f8f9fa;
      }

      .close-cart {
        background: none;
        border: none;
        font-size: 20px;
        cursor: pointer;
        color: #666;
      }

      .cart-items {
        flex: 1;
        overflow-y: auto;
        padding: 20px;
      }

      .cart-item {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 15px 0;
        border-bottom: 1px solid #eee;
      }

      .cart-item-info {
        flex: 1;
      }

      .cart-item-name {
        font-weight: bold;
        margin-bottom: 5px;
      }

      .cart-item-price {
        color: #666;
        font-size: 0.9em;
      }

      .cart-item-controls {
        display: flex;
        align-items: center;
        gap: 10px;
      }

      .quantity-btn {
        background: #007bff;
        color: white;
        border: none;
        width: 30px;
        height: 30px;
        border-radius: 50%;
        cursor: pointer;
        font-size: 16px;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .quantity-btn:hover {
        background: #0056b3;
      }

      .quantity-display {
        min-width: 30px;
        text-align: center;
        font-weight: bold;
      }

      .remove-item {
        background: #dc3545;
        color: white;
        border: none;
        padding: 5px 10px;
        border-radius: 4px;
        cursor: pointer;
        font-size: 12px;
      }

      .cart-footer {
        padding: 20px;
        border-top: 1px solid #eee;
        background: #f8f9fa;
      }

      .cart-total {
        margin-bottom: 15px;
        font-size: 18px;
        text-align: center;
      }

      .purchase-btn {
        background: #28a745 !important;
        width: 100%;
        margin-bottom: 10px;
      }

      .purchase-btn:disabled {
        background: #6c757d !important;
        cursor: not-allowed;
      }

      .clear-cart-btn {
        background: #dc3545 !important;
        width: 100%;
      }

      /* Modal Styles */
      .modal {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0,0,0,0.5);
        z-index: 2000;
        justify-content: center;
        align-items: center;
      }

      .modal.show {
        display: flex;
      }

      .modal-content {
        background: white;
        border-radius: 8px;
        width: 90%;
        max-width: 600px;
        max-height: 80vh;
        overflow-y: auto;
        box-shadow: 0 4px 20px rgba(0,0,0,0.3);
      }

      .modal-header {
        padding: 20px;
        border-bottom: 1px solid #eee;
        display: flex;
        justify-content: space-between;
        align-items: center;
        background: #f8f9fa;
        border-radius: 8px 8px 0 0;
      }

      .close-modal {
        background: none;
        border: none;
        font-size: 20px;
        cursor: pointer;
        color: #666;
      }

      .modal-body {
        padding: 20px;
      }

      .purchase-item {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 10px 0;
        border-bottom: 1px solid #eee;
      }

      .purchase-item-info {
        flex: 1;
      }

      .purchase-item-name {
        font-weight: bold;
        margin-bottom: 5px;
      }

      .purchase-item-details {
        color: #666;
        font-size: 0.9em;
      }

      .purchase-item-total {
        font-weight: bold;
        color: #28a745;
      }

      .purchase-total {
        margin-top: 20px;
        padding-top: 20px;
        border-top: 2px solid #eee;
        text-align: center;
        font-size: 20px;
        color: #28a745;
      }

      .modal-footer {
        padding: 20px;
        border-top: 1px solid #eee;
        display: flex;
        gap: 10px;
        justify-content: flex-end;
        background: #f8f9fa;
        border-radius: 0 0 8px 8px;
      }

      .cancel-btn {
        background: #6c757d !important;
      }

      .confirm-btn {
        background: #28a745 !important;
      }

      /* Loading Overlay */
      .loading-overlay {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0,0,0,0.7);
        z-index: 3000;
        justify-content: center;
        align-items: center;
      }

      .loading-overlay.show {
        display: flex;
      }

      .loading-spinner {
        background: white;
        padding: 40px;
        border-radius: 8px;
        text-align: center;
        box-shadow: 0 4px 20px rgba(0,0,0,0.3);
      }

      .loading-spinner .spinner {
        width: 40px;
        height: 40px;
        margin: 0 auto 20px;
      }

      /* Product Card Add to Cart Button */
      .add-to-cart-btn {
        background: #28a745 !important;
        margin-top: 10px;
        width: 100%;
      }

      .add-to-cart-btn:hover {
        background: #218838 !important;
      }

      .empty-cart {
        text-align: center;
        color: #666;
        padding: 40px 20px;
      }

      .empty-cart-icon {
        font-size: 48px;
        margin-bottom: 10px;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <div class="header">
        <h1>🏪 Store S1 Inventory</h1>
        <p>Frontend Application - Testing Mode</p>
      </div>

      <div class="status">
        <h2>📊 System Status</h2>
        <div class="status-item">
          <span>Frontend Status:</span>
          <span id="frontend-status">✅ Running</span>
        </div>
        <div class="status-item">
          <span>Store S1 API:</span>
          <span id="api-status">🔄 Checking...</span>
        </div>
        <div class="status-item">
          <span>Last Update:</span>
          <span id="last-update">-</span>
        </div>
      </div>

      <div style="text-align: center;">
        <button class="btn" onclick="testAPI()">🔄 Test Store S1 API</button>
        <button class="btn" onclick="loadProducts(false)">📦 Refresh Products</button>
        <button class="btn" onclick="testHealth()">❤️ Health Check</button>
        <button class="btn" onclick="currentPage=1; loadProducts(false)">🏠 Reset to Page 1</button>
        <button class="btn cart-btn" onclick="toggleCart()">🛒 Cart (<span id="cart-count">0</span>)</button>
      </div>

      <div class="products">
        <div class="products-header">
          <h2>📦 Products</h2>
          <div class="auto-refresh-controls">
            <label class="refresh-toggle">
              <input type="checkbox" id="auto-refresh-toggle" checked>
              <span>Auto-refresh (5s)</span>
            </label>
            <span id="refresh-countdown" class="countdown">5</span>
          </div>
        </div>

        <div id="products-content">
          <div class="loading">
            <div class="spinner"></div>
            <p>Loading products...</p>
          </div>
        </div>

        <div id="pagination-controls" class="pagination" style="display: none;">
          <button id="prev-btn" class="btn pagination-btn" onclick="previousPage()">← Previous</button>
          <div class="pagination-info">
            <span id="page-info">Page 1 of 1</span>
            <span id="total-info">(0 products total)</span>
          </div>
          <button id="next-btn" class="btn pagination-btn" onclick="nextPage()">Next →</button>
        </div>
      </div>
    </div>

    <!-- Shopping Cart Sidebar -->
    <div id="cart-sidebar" class="cart-sidebar">
      <div class="cart-header">
        <h3>🛒 Shopping Cart</h3>
        <button class="close-cart" onclick="toggleCart()">✕</button>
      </div>
      <div id="cart-items" class="cart-items">
        <!-- Cart items will be inserted here -->
      </div>
      <div class="cart-footer">
        <div class="cart-total">
          <strong>Total: $<span id="cart-total">0.00</span></strong>
        </div>
        <button class="btn purchase-btn" onclick="showPurchaseModal()" id="purchase-btn" disabled>
          💳 Purchase
        </button>
        <button class="btn clear-cart-btn" onclick="clearCart()">
          🗑️ Clear Cart
        </button>
      </div>
    </div>

    <!-- Purchase Modal -->
    <div id="purchase-modal" class="modal">
      <div class="modal-content">
        <div class="modal-header">
          <h3>💳 Purchase Summary</h3>
          <button class="close-modal" onclick="closePurchaseModal()">✕</button>
        </div>
        <div class="modal-body">
          <div id="purchase-summary">
            <!-- Purchase summary will be inserted here -->
          </div>
          <div class="purchase-total">
            <strong>Total Amount: $<span id="purchase-total">0.00</span></strong>
          </div>
        </div>
        <div class="modal-footer">
          <button class="btn cancel-btn" onclick="closePurchaseModal()">❌ Cancel</button>
          <button class="btn confirm-btn" onclick="confirmPurchase()" id="confirm-purchase-btn">
            ✅ Confirm Purchase
          </button>
        </div>
      </div>
    </div>

    <!-- Loading Overlay -->
    <div id="loading-overlay" class="loading-overlay">
      <div class="loading-spinner">
        <div class="spinner"></div>
        <p id="loading-message">Processing purchase...</p>
      </div>
    </div>

    <script>
      // Global state
      let currentPage = 1;
      let totalProducts = 0;
      let productsPerPage = 5;
      let allProducts = [];
      let autoRefreshInterval = null;
      let countdownInterval = null;
      let countdownSeconds = 5;

      // Shopping cart state
      let cart = [];
      let isCartOpen = false;
      let isLoading = false;

      // Shopping Cart Functions

      function addToCart(productId, productName, price, available, version) {
        // Validate that price is a valid number
        if (typeof price !== 'number' || isNaN(price) || price <= 0) {
          showMessage(`Invalid price for ${productName}`, 'error');
          return;
        }

        // Check if product is already in cart
        const existingItem = cart.find(item => item.productId === productId);

        if (existingItem) {
          // Check if we can add more
          if (existingItem.quantity < available) {
            existingItem.quantity += 1;
            showMessage(`Added another ${productName} to cart`, 'success');
          } else {
            showMessage(`Cannot add more ${productName} - insufficient stock`, 'error');
            return;
          }
        } else {
          // Add new item to cart
          cart.push({
            productId,
            productName,
            price,
            quantity: 1,
            available,
            version
          });
          showMessage(`${productName} added to cart`, 'success');
        }

        updateCartDisplay();
      }

      function removeFromCart(productId) {
        const index = cart.findIndex(item => item.productId === productId);
        if (index !== -1) {
          const item = cart[index];
          cart.splice(index, 1);
          showMessage(`${item.productName} removed from cart`, 'info');
          updateCartDisplay();
        }
      }

      function updateQuantity(productId, change) {
        const item = cart.find(item => item.productId === productId);
        if (!item) return;

        const newQuantity = item.quantity + change;

        if (newQuantity <= 0) {
          removeFromCart(productId);
          return;
        }

        if (newQuantity > item.available) {
          showMessage(`Cannot add more ${item.productName} - insufficient stock`, 'error');
          return;
        }

        item.quantity = newQuantity;
        updateCartDisplay();
      }

      function clearCart() {
        if (cart.length === 0) return;

        if (confirm('Are you sure you want to clear the cart?')) {
          cart = [];
          updateCartDisplay();
          showMessage('Cart cleared', 'info');
        }
      }

      function updateCartDisplay() {
        const cartCount = document.getElementById('cart-count');
        const cartItems = document.getElementById('cart-items');
        const cartTotal = document.getElementById('cart-total');
        const purchaseBtn = document.getElementById('purchase-btn');

        // Update cart count
        const totalItems = cart.reduce((sum, item) => sum + item.quantity, 0);
        cartCount.textContent = totalItems;

        // Update cart items
        if (cart.length === 0) {
          cartItems.innerHTML = `
            <div class="empty-cart">
              <div class="empty-cart-icon">🛒</div>
              <p>Your cart is empty</p>
              <p>Add some products to get started!</p>
            </div>
          `;
          cartTotal.textContent = '0.00';
          purchaseBtn.disabled = true;
        } else {
          let html = '';
          let total = 0;

          cart.forEach(item => {
            const itemTotal = item.price * item.quantity;
            total += itemTotal;

            html += `
              <div class="cart-item">
                <div class="cart-item-info">
                  <div class="cart-item-name">${item.productName}</div>
                  <div class="cart-item-price">$${item.price.toFixed(2)} each</div>
                </div>
                <div class="cart-item-controls">
                  <button class="quantity-btn" onclick="updateQuantity('${item.productId}', -1)">-</button>
                  <span class="quantity-display">${item.quantity}</span>
                  <button class="quantity-btn" onclick="updateQuantity('${item.productId}', 1)">+</button>
                  <button class="remove-item" onclick="removeFromCart('${item.productId}')">Remove</button>
                </div>
              </div>
            `;
          });

          cartItems.innerHTML = html;
          cartTotal.textContent = total.toFixed(2);
          purchaseBtn.disabled = false;
        }
      }

      function toggleCart() {
        const cartSidebar = document.getElementById('cart-sidebar');
        isCartOpen = !isCartOpen;

        if (isCartOpen) {
          cartSidebar.classList.add('open');
        } else {
          cartSidebar.classList.remove('open');
        }
      }

      // Purchase Functions
      function showPurchaseModal() {
        if (cart.length === 0) return;

        const modal = document.getElementById('purchase-modal');
        const summary = document.getElementById('purchase-summary');
        const total = document.getElementById('purchase-total');

        let html = '';
        let totalAmount = 0;

        cart.forEach(item => {
          const itemTotal = item.price * item.quantity;
          totalAmount += itemTotal;

          html += `
            <div class="purchase-item">
              <div class="purchase-item-info">
                <div class="purchase-item-name">${item.productName}</div>
                <div class="purchase-item-details">
                  Quantity: ${item.quantity} × $${item.price.toFixed(2)} = $${itemTotal.toFixed(2)}
                </div>
              </div>
              <div class="purchase-item-total">$${itemTotal.toFixed(2)}</div>
            </div>
          `;
        });

        summary.innerHTML = html;
        total.textContent = totalAmount.toFixed(2);
        modal.classList.add('show');
      }

      function closePurchaseModal() {
        const modal = document.getElementById('purchase-modal');
        modal.classList.remove('show');
      }

      function generateUUID() {
        return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
          const r = Math.random() * 16 | 0;
          const v = c == 'x' ? r : (r & 0x3 | 0x8);
          return v.toString(16);
        });
      }

      function showLoadingOverlay(message = 'Processing purchase...') {
        const overlay = document.getElementById('loading-overlay');
        const messageEl = document.getElementById('loading-message');
        messageEl.textContent = message;
        overlay.classList.add('show');
      }

      function hideLoadingOverlay() {
        const overlay = document.getElementById('loading-overlay');
        overlay.classList.remove('show');
      }

      async function confirmPurchase() {
        if (cart.length === 0) return;

        showLoadingOverlay('Processing purchase...');
        closePurchaseModal();

        const purchaseResults = [];
        let successCount = 0;
        let failureCount = 0;

        try {
          // Process each item in the cart
          for (let i = 0; i < cart.length; i++) {
            const item = cart[i];
            showLoadingOverlay(`Processing ${item.productName} (${i + 1}/${cart.length})...`);

            const result = await processPurchaseItem(item);
            purchaseResults.push(result);

            if (result.success) {
              successCount++;
            } else {
              failureCount++;
            }
          }

          // Show results
          hideLoadingOverlay();

          if (failureCount === 0) {
            showMessage(`🎉 Purchase successful! ${successCount} items purchased.`, 'success');
            cart = []; // Clear cart on successful purchase
            updateCartDisplay();
            toggleCart(); // Close cart

            // Refresh products to show updated inventory
            setTimeout(() => loadProducts(true), 1000);
          } else if (successCount === 0) {
            showMessage(`❌ Purchase failed for all items. Please try again.`, 'error');
          } else {
            showMessage(`⚠️ Partial success: ${successCount} items purchased, ${failureCount} failed.`, 'warning');

            // Remove successful items from cart
            cart = cart.filter(cartItem => {
              const result = purchaseResults.find(r => r.productId === cartItem.productId);
              return !result || !result.success;
            });
            updateCartDisplay();

            // Refresh products
            setTimeout(() => loadProducts(true), 1000);
          }

        } catch (error) {
          hideLoadingOverlay();
          console.error('Purchase error:', error);
          showMessage('❌ Purchase failed due to system error. Please try again.', 'error');
        }
      }

      async function processPurchaseItem(item, maxRetries = 3) {
        let attempt = 0;
        let currentVersion = item.version;

        while (attempt < maxRetries) {
          attempt++;

          try {
            // Generate unique idempotency key for each attempt
            const idempotencyKey = generateUUID();

            // Create purchase request (negative delta to reduce inventory)
            const purchaseRequest = {
              storeId: 'store-s1',
              productId: item.productId,
              delta: -item.quantity, // Negative to reduce inventory
              version: currentVersion,
              idempotencyKey: idempotencyKey
            };

            console.log(`Purchase attempt ${attempt} for ${item.productName}:`, purchaseRequest);

            // Send purchase request to Store S1 API
            const response = await fetch('/api/inventory/updates', {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json',
                'X-API-Key': 'store-s1-key'
              },
              body: JSON.stringify(purchaseRequest)
            });

            const responseData = await response.json();

            if (response.ok && responseData.applied) {
              console.log(`Purchase successful for ${item.productName}:`, responseData);
              return {
                success: true,
                productId: item.productId,
                productName: item.productName,
                quantity: item.quantity,
                newQuantity: responseData.newQuantity,
                newVersion: responseData.newVersion,
                attempt: attempt
              };
            } else if (response.status === 409 || responseData.errorType === 'version_conflict') {
              // Version conflict - fetch current product data and retry
              console.log(`Version conflict for ${item.productName}, fetching current data...`);

              const currentProduct = await fetchCurrentProductData(item.productId);
              if (currentProduct && currentProduct.version) {
                currentVersion = currentProduct.version;
                console.log(`Updated version for ${item.productName}: ${currentVersion}`);

                // Check if there's still enough inventory
                if (currentProduct.available < item.quantity) {
                  return {
                    success: false,
                    productId: item.productId,
                    productName: item.productName,
                    error: 'insufficient_inventory',
                    message: `Insufficient inventory. Available: ${currentProduct.available}, Requested: ${item.quantity}`,
                    attempt: attempt
                  };
                }

                // Continue to next attempt with updated version
                continue;
              } else {
                return {
                  success: false,
                  productId: item.productId,
                  productName: item.productName,
                  error: 'version_fetch_failed',
                  message: 'Failed to fetch current product version',
                  attempt: attempt
                };
              }
            } else if (responseData.errorType === 'insufficient_inventory') {
              return {
                success: false,
                productId: item.productId,
                productName: item.productName,
                error: 'insufficient_inventory',
                message: responseData.errorMessage || 'Insufficient inventory',
                attempt: attempt
              };
            } else {
              // Other error
              return {
                success: false,
                productId: item.productId,
                productName: item.productName,
                error: responseData.errorType || 'unknown_error',
                message: responseData.errorMessage || `HTTP ${response.status}`,
                attempt: attempt
              };
            }

          } catch (error) {
            console.error(`Purchase attempt ${attempt} failed for ${item.productName}:`, error);

            if (attempt === maxRetries) {
              return {
                success: false,
                productId: item.productId,
                productName: item.productName,
                error: 'network_error',
                message: error.message || 'Network error',
                attempt: attempt
              };
            }

            // Wait before retry
            await new Promise(resolve => setTimeout(resolve, 1000 * attempt));
          }
        }

        return {
          success: false,
          productId: item.productId,
          productName: item.productName,
          error: 'max_retries_exceeded',
          message: `Failed after ${maxRetries} attempts`,
          attempt: maxRetries
        };
      }

      async function fetchCurrentProductData(productId) {
        try {
          const response = await fetch(`/api/inventory/${productId}`, {
            headers: {
              'X-API-Key': 'store-s1-key'
            }
          });

          if (response.ok) {
            const product = await response.json();
            return product;
          } else {
            console.error(`Failed to fetch current data for ${productId}:`, response.status);
            return null;
          }
        } catch (error) {
          console.error(`Error fetching current data for ${productId}:`, error);
          return null;
        }
      }

      // Update last update time
      function updateTime() {
        document.getElementById('last-update').textContent = new Date().toLocaleTimeString();
      }

      // Auto-refresh countdown
      function startCountdown() {
        countdownSeconds = 5;
        const countdownEl = document.getElementById('refresh-countdown');

        countdownInterval = setInterval(() => {
          countdownEl.textContent = countdownSeconds;
          countdownSeconds--;

          if (countdownSeconds < 0) {
            countdownSeconds = 5;
            if (document.getElementById('auto-refresh-toggle').checked && !isLoading) {
              loadProducts(true); // Silent refresh
            }
          }
        }, 1000);
      }

      // Stop countdown
      function stopCountdown() {
        if (countdownInterval) {
          clearInterval(countdownInterval);
          countdownInterval = null;
        }
        document.getElementById('refresh-countdown').textContent = '-';
      }

      // Test API connectivity
      async function testAPI() {
        const statusEl = document.getElementById('api-status');
        statusEl.textContent = '🔄 Testing...';

        try {
          const response = await fetch('/api/inventory', {
            headers: {
              'X-API-Key': 'demo'
            }
          });

          if (response.ok) {
            statusEl.textContent = '✅ Connected';
            showMessage('API connection successful!', 'success');
          } else {
            statusEl.textContent = '❌ Error ' + response.status;
            showMessage('API connection failed: ' + response.status, 'error');
          }
        } catch (error) {
          statusEl.textContent = '❌ Failed';
          showMessage('API connection error: ' + error.message, 'error');
        }

        updateTime();
      }

      // Load products with pagination support
      async function loadProducts(silent = false) {
        if (isLoading) return;

        isLoading = true;
        const contentEl = document.getElementById('products-content');

        if (!silent) {
          contentEl.innerHTML = '<div class="loading"><div class="spinner"></div><p>Loading products...</p></div>';
        } else {
          contentEl.classList.add('refreshing');
        }

        try {
          // Use offset-based pagination with limit parameter
          const url = `/api/inventory?offset=${(currentPage - 1) * productsPerPage}&limit=${productsPerPage}`;
          const response = await fetch(url, {
            headers: {
              'X-API-Key': 'demo'
            }
          });

          if (response.ok) {
            const data = await response.json();
            console.log('API Response received:', data); // Debug log

            // Handle different response formats
            if (data.products && data.pagination) {
              // New pagination format (Central API and updated Store S1 API)
              console.log('Using pagination format'); // Debug log
              allProducts = data.products || [];
              totalProducts = data.pagination.total_count || 0;

              // Update pagination info from server response
              const serverOffset = data.pagination.offset || 0;
              const serverLimit = data.pagination.limit || productsPerPage;
              currentPage = Math.floor(serverOffset / serverLimit) + 1;
            } else if (Array.isArray(data)) {
              // Direct array format (legacy Store S1 API)
              console.log('Using direct array format'); // Debug log
              allProducts = data || [];
              totalProducts = allProducts.length;

              // For direct array, we need to handle pagination client-side
              const startIndex = (currentPage - 1) * productsPerPage;
              const endIndex = startIndex + productsPerPage;
              allProducts = allProducts.slice(startIndex, endIndex);
            } else {
              // Fallback for unknown format
              console.warn('Unknown response format:', data);
              allProducts = [];
              totalProducts = 0;
            }

            console.log('Processed products:', allProducts.length, 'Total:', totalProducts); // Debug log

            // Reset to page 1 if current page is beyond available pages
            const maxPages = Math.ceil(totalProducts / productsPerPage);
            if (currentPage > maxPages && maxPages > 0) {
              currentPage = 1;
            }

            displayCurrentPage();
            updatePaginationControls();

            if (!silent) {
              showMessage(`Loaded ${totalProducts} products successfully!`, 'success');
            }

            // Update API status
            document.getElementById('api-status').textContent = '✅ Connected';
          } else {
            contentEl.innerHTML = '<p>❌ Failed to load products: ' + response.status + '</p>';
            if (!silent) {
              showMessage('Failed to load products: ' + response.status, 'error');
            }
            document.getElementById('api-status').textContent = '❌ Error ' + response.status;
          }
        } catch (error) {
          console.error('Failed to load products:', error);

          // Parse structured error response
          let errorMessage = 'Unknown error occurred';
          let errorCode = 'unknown_error';

          try {
            // Try to parse as structured error response
            if (error.message && error.message.includes('{')) {
              const errorData = JSON.parse(error.message.substring(error.message.indexOf('{')));
              if (errorData.error) {
                errorCode = errorData.error.code || 'unknown_error';
                errorMessage = errorData.error.message || errorMessage;

                // Add specific handling for different error types
                switch (errorCode) {
                  case 'storage_error':
                    errorMessage = 'Storage system is temporarily unavailable';
                    break;
                  case 'product_not_found':
                    errorMessage = 'Product not found in inventory';
                    break;
                  case 'version_conflict':
                    errorMessage = 'Version conflict - data may be outdated';
                    break;
                  case 'insufficient_inventory':
                    errorMessage = 'Insufficient inventory for this operation';
                    break;
                  default:
                    // Use the provided message
                    break;
                }
              }
            } else {
              errorMessage = error.message || errorMessage;
            }
          } catch (parseError) {
            // Fallback to original error message
            errorMessage = error.message || errorMessage;
          }

          contentEl.innerHTML = `<p>❌ Error loading products: ${errorMessage}</p>`;
          if (!silent) {
            showMessage(`Error loading products: ${errorMessage}`, 'error');
          }
          document.getElementById('api-status').textContent = '❌ Failed';
        } finally {
          isLoading = false;
          contentEl.classList.remove('refreshing');
          updateTime();
        }
      }

      // Display current page of products
      function displayCurrentPage() {
        const contentEl = document.getElementById('products-content');

        if (!allProducts || allProducts.length === 0) {
          contentEl.innerHTML = '<p>No products found</p>';
          document.getElementById('pagination-controls').style.display = 'none';
          return;
        }

        // Products are already paginated by the server, so use them directly
        const currentProducts = allProducts;

        // Display products
        let html = '<div class="product-grid">';

        currentProducts.forEach(product => {
          const stockStatus = getStockStatus(product.available);
          const stockColor = getStockColor(product.available);

          // Handle different date field formats
          const dateField = product.lastUpdated || product.last_updated || product.LastUpdated;
          const formattedDate = formatDate(dateField);

          // Handle different name and ID field formats
          const productName = product.name || product.Name || 'Unknown Product';
          const productId = product.productId || product.product_id || product.ProductID || 'Unknown ID';

          // Handle version field
          const version = product.version || product.Version || 'N/A';

          // Handle available field
          const available = product.available !== undefined ? product.available :
                           (product.Available !== undefined ? product.Available : 0);

          // Use real price from API response
          const price = product.price || 0;

          // Validate price
          if (typeof price !== 'number' || isNaN(price) || price < 0) {
            console.warn(`Invalid price for product ${productId}:`, price);
          }

          html += `
            <div class="product-card">
              <div class="product-header">
                <h3>${productName}</h3>
                <span class="product-id">(${productId})</span>
              </div>
              <p><strong>Available:</strong> <span style="color: ${stockColor};">${available} ${stockStatus}</span></p>
              <p><strong>Version:</strong> ${version}</p>
              <p><strong>Updated:</strong> ${formattedDate}</p>
              <p><strong>Price:</strong> $${price.toFixed(2)}</p>
              <button class="btn add-to-cart-btn" onclick="addToCart('${productId}', '${productName.replace(/'/g, "\\'")}', ${price}, ${available}, ${version})"
                      ${available <= 0 || price <= 0 ? 'disabled' : ''}>
                🛒 Add to Cart
              </button>
            </div>
          `;
        });

        html += '</div>';
        contentEl.innerHTML = html;

        // Show pagination controls
        const paginationEl = document.getElementById('pagination-controls');
        if (paginationEl) {
          paginationEl.style.display = 'flex';
        }
      }

      // Get stock status text
      function getStockStatus(available) {
        if (available === 0) return '(Out of Stock)';
        if (available <= 5) return '(Low Stock)';
        return '(In Stock)';
      }

      // Get stock color
      function getStockColor(available) {
        if (available === 0) return '#e74c3c';
        if (available <= 5) return '#f39c12';
        return '#27ae60';
      }

      // Helper function to format dates
      function formatDate(dateString) {
        if (!dateString) return 'Never updated';

        try {
          const date = new Date(dateString);

          // Check if date is valid
          if (isNaN(date.getTime())) {
            return 'Invalid date';
          }

          // Format as "Jan 15, 2024 at 10:30 AM"
          const options = {
            year: 'numeric',
            month: 'short',
            day: 'numeric',
            hour: '2-digit',
            minute: '2-digit',
            hour12: true
          };

          return date.toLocaleDateString('en-US', options);
        } catch (error) {
          console.warn('Error formatting date:', dateString, error);
          return 'Unknown';
        }
      }

      // Update pagination controls
      function updatePaginationControls() {
        const totalPages = Math.ceil(totalProducts / productsPerPage);
        const startItem = totalProducts === 0 ? 0 : (currentPage - 1) * productsPerPage + 1;
        const endItem = Math.min(currentPage * productsPerPage, totalProducts);

        document.getElementById('page-info').textContent = `Page ${currentPage} of ${totalPages}`;
        document.getElementById('total-info').textContent = `(${startItem}-${endItem} of ${totalProducts} products)`;

        document.getElementById('prev-btn').disabled = currentPage <= 1;
        document.getElementById('next-btn').disabled = currentPage >= totalPages;
      }

      // Navigation functions
      function previousPage() {
        if (currentPage > 1) {
          currentPage--;
          loadProducts(true); // Reload data for new page
        }
      }

      function nextPage() {
        const totalPages = Math.ceil(totalProducts / productsPerPage);
        if (currentPage < totalPages) {
          currentPage++;
          loadProducts(true); // Reload data for new page
        }
      }

      // Test health
      async function testHealth() {
        try {
          const response = await fetch('/health');
          if (response.ok) {
            showMessage('Health check passed!', 'success');
          } else {
            showMessage('Health check failed: ' + response.status, 'error');
          }
        } catch (error) {
          showMessage('Health check error: ' + error.message, 'error');
        }
        updateTime();
      }

      // Show message
      function showMessage(message, type) {
        const existing = document.querySelector('.message');
        if (existing) existing.remove();

        const div = document.createElement('div');
        div.className = 'message ' + type;
        div.innerHTML = `<p>${message}</p>`;
        document.querySelector('.container').appendChild(div);

        setTimeout(() => div.remove(), 5000);
      }

      // Toggle auto-refresh
      function toggleAutoRefresh() {
        const toggle = document.getElementById('auto-refresh-toggle');

        if (toggle.checked) {
          startCountdown();
          showMessage('Auto-refresh enabled (every 5 seconds)', 'success');
        } else {
          stopCountdown();
          showMessage('Auto-refresh disabled', 'warning');
        }
      }

      // Initialize application
      function initializeApp() {
        updateTime();
        setInterval(updateTime, 1000);

        // Initialize cart display
        updateCartDisplay();

        // Set up auto-refresh toggle
        const toggleEl = document.getElementById('auto-refresh-toggle');
        if (toggleEl) {
          toggleEl.addEventListener('change', toggleAutoRefresh);
        } else {
          console.error('Auto-refresh toggle element not found');
        }

        // Auto-load products on page load
        setTimeout(() => {
          loadProducts();
          testAPI();
        }, 500);

        // Fallback: Force load after 2 seconds if nothing is displayed
        setTimeout(() => {
          const contentEl = document.getElementById('products-content');
          if (contentEl && contentEl.innerHTML.includes('Loading products...')) {
            console.warn('Fallback: Retrying product load...');
            loadProducts();
          }
        }, 2000);

        // Start auto-refresh countdown
        setTimeout(startCountdown, 1000);
      }

      // Initialize when DOM is ready
      function ensureInitialization() {
        if (document.readyState === 'loading') {
          document.addEventListener('DOMContentLoaded', initializeApp);
        } else if (document.readyState === 'interactive' || document.readyState === 'complete') {
          // DOM is ready, but let's wait a bit more to ensure all elements are rendered
          setTimeout(initializeApp, 100);
        } else {
          // Fallback
          setTimeout(ensureInitialization, 100);
        }
      }

      // Start initialization
      ensureInitialization();
    </script>
  </body>
</html>
